#ifndef SOY_LIB_MINI_H
#define SOY_LIB_MINI_H

/*=========================================================================*/
/* READ ONLY                                                               */
/*=========================================================================*/

const unsigned short g_packedFont0[1792] = {
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,56,68,170,130,198,186,68,56,0,0,0,0,0,0,56,
124,214,254,186,198,124,56,0,0,0,0,0,0,108,254,254,254,124,56,56,16,16,0,0,0,
0,0,16,56,124,254,254,124,56,16,0,0,0,0,0,16,56,56,124,254,254,108,16,124,0,
0,0,0,0,16,56,124,254,254,254,108,16,124,0,0,0,0,0,0,0,16,56,124,56,16,0,0,0,
0,0,0,0,254,254,238,198,130,198,238,254,254,0,0,0,0,0,0,0,56,68,68,68,56,0,0,
0,0,0,0,0,254,254,198,186,186,186,198,254,254,0,0,0,0,0,224,192,160,28,34,34,
34,28,0,0,0,0,0,0,56,68,68,68,56,16,124,16,16,0,0,0,0,0,24,24,40,104,72,72,
46,6,0,0,0,0,0,0,224,184,136,136,136,136,102,102,0,0,0,0,0,0,16,84,56,68,
198,68,56,84,16,0,0,0,0,0,0,0,4,12,28,60,28,12,4,0,0,0,0,0,0,0,64,96,112,120,
112,96,64,0,0,0,0,0,16,56,84,16,16,16,84,56,16,0,0,0,0,36,36,36,36,36,36,0,0,
36,36,0,0,0,0,60,42,42,42,60,40,40,40,40,40,40,0,0,0,56,68,4,24,36,72,48,64,
68,56,0,0,0,0,0,0,0,0,0,254,254,254,254,254,0,0,0,0,16,56,84,16,16,84,56,16,
0,124,0,0,0,0,0,16,56,84,16,16,16,16,16,16,16,0,0,0,0,16,16,16,16,16,16,16,
84,56,16,0,0,0,0,0,0,0,16,32,126,32,16,0,0,0,0,0,0,0,0,0,8,4,126,4,8,0,0,0,0,
0,0,0,0,0,0,12,12,12,12,124,0,0,0,0,0,0,0,0,40,68,254,68,40,0,0,0,0,0,0,0,0,
0,16,56,124,254,0,0,0,0,0,0,0,0,0,0,254,124,56,16,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,16,16,16,16,16,16,16,0,0,16,0,0,0,0,36,36,36,36,0,0,0,0,0,0,
0,0,0,0,72,72,72,252,72,36,126,36,36,36,0,0,0,0,16,56,84,20,20,56,80,80,84,
56,16,0,0,0,76,82,50,44,16,16,104,152,148,100,0,0,0,0,24,36,36,24,8,148,98,
34,34,220,0,0,0,0,32,32,16,8,0,0,0,0,0,0,0,0,0,0,32,16,16,8,8,8,8,8,16,16,32,
0,0,0,8,16,16,32,32,32,32,32,16,16,8,0,0,0,0,16,84,56,56,84,16,0,0,0,0,0,0,
0,0,0,0,16,16,124,16,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,48,48,32,24,0,0,0,0,0,0,
0,124,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,48,48,0,0,0,0,64,64,32,32,16,16,8,8,4,
4,0,0,0,0,0,48,72,72,72,72,72,72,72,48,0,0,0,0,0,16,24,20,16,16,16,16,16,124,
0,0,0,0,0,56,68,64,64,32,16,8,4,124,0,0,0,0,0,56,68,64,64,48,64,64,68,56,0,0,
0,0,0,64,96,80,72,68,68,252,64,64,0,0,0,0,0,124,4,4,60,64,64,68,68,56,0,0,0,
0,0,56,68,4,4,60,68,68,68,56,0,0,0,0,0,124,68,64,32,32,32,16,16,16,0,0,0,0,0,
56,68,68,68,56,68,68,68,56,0,0,0,0,0,56,68,68,68,120,64,64,68,56,0,0,0,0,0,0,
0,48,48,0,0,0,48,48,0,0,0,0,0,0,0,48,48,0,0,0,48,48,32,24,0,0,64,32,16,8,4,2,
4,8,16,32,64,0,0,0,0,0,0,0,62,0,0,62,0,0,0,0,0,0,2,4,8,16,32,64,32,16,8,4,2,
0,0,0,56,68,68,64,32,16,16,0,0,16,0,0,0,0,16,40,68,116,84,84,116,4,72,48,0,0,
0,0,0,16,16,40,40,40,68,124,68,68,0,0,0,0,0,28,36,36,36,60,68,68,68,60,0,0,0,
0,0,56,68,68,4,4,4,68,68,56,0,0,0,0,0,28,36,68,68,68,68,68,36,28,0,0,0,0,0,
124,4,4,4,60,4,4,4,124,0,0,0,0,0,124,4,4,4,60,4,4,4,4,0,0,0,0,0,56,68,4,4,
100,68,68,100,88,0,0,0,0,0,68,68,68,68,124,68,68,68,68,0,0,0,0,0,124,16,16,
16,16,16,16,16,124,0,0,0,0,0,120,32,32,32,32,32,36,36,24,0,0,0,0,0,68,36,20,
12,20,36,36,68,68,0,0,0,0,0,4,4,4,4,4,4,4,4,124,0,0,0,0,0,66,66,102,102,90,
90,66,66,66,0,0,0,0,0,68,76,76,84,84,100,100,68,68,0,0,0,0,0,56,68,68,68,68,
68,68,68,56,0,0,0,0,0,60,68,68,68,60,4,4,4,4,0,0,0,0,0,56,68,68,68,68,68,68,
68,56,16,96,0,0,0,60,68,68,68,60,36,68,68,68,0,0,0,0,0,56,68,4,8,48,64,68,68,
56,0,0,0,0,0,124,16,16,16,16,16,16,16,16,0,0,0,0,0,68,68,68,68,68,68,68,68,
56,0,0,0,0,0,68,68,68,40,40,40,16,16,16,0,0,0,0,0,130,130,130,146,84,84,84,
40,40,0,0,0,0,0,68,68,40,40,16,40,40,68,68,0,0,0,0,0,68,68,68,40,16,16,16,16,
16,0,0,0,0,0,124,64,64,32,16,8,4,4,124,0,0,0,0,120,8,8,8,8,8,8,8,8,8,120,0,0,
0,4,4,8,8,16,16,32,32,64,64,0,0,0,0,60,32,32,32,32,32,32,32,32,32,60,0,0,0,0,
16,56,108,68,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,126,0,0,0,8,8,16,32,0,0,0,
0,0,0,0,0,0,0,0,0,0,56,68,64,120,68,68,120,0,0,0,0,0,4,4,52,76,68,68,68,76,
52,0,0,0,0,0,0,0,56,68,4,4,4,68,56,0,0,0,0,0,64,64,88,100,68,68,68,100,88,0,
0,0,0,0,0,0,56,68,68,124,4,68,56,0,0,0,0,0,96,16,16,124,16,16,16,16,16,0,0,0,
0,0,0,0,88,100,68,68,68,100,88,64,68,56,0,0,4,4,52,76,68,68,68,68,68,0,0,0,
0,0,32,0,56,32,32,32,32,32,32,0,0,0,0,0,32,0,56,32,32,32,32,32,32,32,36,24,
0,0,4,4,36,20,12,12,20,36,68,0,0,0,0,0,56,32,32,32,32,32,32,32,32,0,0,0,0,0,
0,0,44,84,84,84,84,84,84,0,0,0,0,0,0,0,52,76,68,68,68,68,68,0,0,0,0,0,0,0,56,
68,68,68,68,68,56,0,0,0,0,0,0,0,52,76,68,68,68,76,52,4,4,4,0,0,0,0,88,100,68,
68,68,100,88,64,64,64,0,0,0,0,52,76,4,4,4,4,4,0,0,0,0,0,0,0,56,68,4,56,64,68,
56,0,0,0,0,0,16,16,124,16,16,16,16,16,96,0,0,0,0,0,0,0,68,68,68,68,68,100,88,
0,0,0,0,0,0,0,68,68,68,40,40,16,16,0,0,0,0,0,0,0,68,68,84,84,84,84,40,0,0,0,
0,0,0,0,68,68,40,16,40,68,68,0,0,0,0,0,0,0,68,68,72,72,80,48,32,32,36,24,0,0,
0,0,124,64,32,16,8,4,124,0,0,0,96,16,16,16,16,16,12,16,16,16,16,16,96,0,0,16,
16,16,16,16,16,16,16,16,16,16,16,0,12,16,16,16,16,16,96,16,16,16,16,16,12,0,
0,0,72,84,36,0,0,0,0,0,0,0,0,0,0,0,0,0,16,56,108,68,68,124,0,0,0,0
};

/*=========================================================================*/
/* SYSTEM                                                                  */
/*=========================================================================*/

#define _CRT_SECURE_NO_WARNINGS

#include "stdio.h"
#include "math.h"

#ifdef UNICODE
#error "No unicode support -> go away!\n"
#endif

#ifdef _WIN32
#define SOY_WIN32
#define SOY_OS_NAME "Windows"

#include "windows.h"
#include "windowsx.h"

#endif
#ifdef __linux__
#define SOY_LINUX
#error "No linux support -> go away!"
#define SOY_OS_NAME "Linux"
#endif

/*=========================================================================*/
/* CORE DEFINES                                                            */
/*=========================================================================*/

#ifdef SOY_WIN32
typedef __int8 int8;
typedef __int16 int16;
typedef __int32 int32;
typedef __int64 int64;
typedef UINT8 uint8;
typedef UINT16 uint16;
typedef UINT32 uint32;
typedef UINT64 uint64;
#endif /* SOY_WIN32 */

#ifdef SOY_LINUX
typedef char int8;
typedef short int16;
typedef long int32;
typedef long long int64;
typedef unsigned char uint8;
typedef unsigned short uint16;
typedef unsigned long uint32;
typedef unsigned long long uint64;
#endif /* SOY_LINUX */

typedef double real64;
typedef float real32;

#define SOY_GLOBAL static

#undef TRUE
#define TRUE 1
#undef FALSE
#define FALSE 0

#define SOY_PI 3.141592653f
#define SOY_2PI 6.283185307f
#define SOY_EULER 2.71828f

#define SOY_UNUSED(x) (void)(x)

#define SOY_SWAP(x, y, temp) { temp = x; x = y; y = temp; }

#define SOY_BITSET(x, whence) ((x) |= (1<<(whence)))
#define SOY_BITCLEAR(x, whence) ((x) &= ~(1<<(whence)))
#define SOY_BITFLIP(x, whence) ((x) ^= (1<<(whence)))
#define SOY_BITCHECK(x, whence) ((x) & (1<<(whence)))

#define SOY_MAX(a, b) (((a) > (b)) ? (a) : (b))
#define SOY_MIN(a, b) (((a) < (b)) ? (a) : (b))
#define SOY_SQR(x) ((x)*(x))
#define SOY_CUB(x) ((x)*(x)*(x))
#define SOY_FASTFLOOR(x) (((x) > 0) ? (int64)(x) : (int64)(x) - 1)
#define SOY_SIGN(x) ((x) == 0 ? 0 : ((x) > 0 ? 1 : -1))

#define SOY_randInt(modulo) (rand()%modulo)

#define SOY_lerp(start, end, t) ((1.0f - (t)) * (start) + (t) * (end))

#define SOY_distance(x1, y1, x2, y2) \
  ((real32)sqrt(((x2)-(x1))*((x2)-(x1))+((y2)-(y1))*((y2)-(y1))))

#define SOY_worldToScreen(worldCoord, offset, scale) \
  ((int32)((((worldCoord) - (offset)) * (scale))))

#define SOY_screenToWorld(screenCoord, offset, scale) \
  ((((real32)(screenCoord) / (scale) + (offset))))

#define SOY_sign(x) ((x) > 0 ? 1 : ((x) < 0 ? -1 : 0))

real32 SOY_intBounds(real32 s, real32 ds) {
  return (ds > 0 ? ceil(s) - s : s -floor(s)) / fabs(ds);
}

typedef enum enum_soyKeyCode {
  SOY_LBUTTON = 0x01,   SOY_RBUTTON = 0x02,   SOY_CANCEL = 0x03,
  SOY_MBUTTON = 0x04,   SOY_XBUTTON1 = 0x05,  SOY_XBUTTON2 = 0x06,
  SOY_BACKSPACE = 0x08, SOY_TAB= 0x09,        SOY_CLEAR = 0x0C,
  SOY_RETURN = 0x0D,    SOY_SHIFT = 0x10,     SOY_CONTROL = 0x11,
  SOY_ALT = 0x12,       SOY_PAUSE = 0x13,     SOY_CAPS = 0x14,
  SOY_ESC = 0x1B,       SOY_SPACE = 0x20,     SOY_PGUP = 0x21,
  SOY_PGDOWN = 0x22,    SOY_END = 0x23,       SOY_HOME = 0x24,
  SOY_LEFT = 0x25,      SOY_UP = 0x26,        SOY_RIGHT = 0x27,
  SOY_DOWN = 0x28,      SOY_SELECT = 0x29,    SOY_PRINT = 0x2A,
  SOY_EXEC = 0x2B,      SOY_PRINTSCR = 0x2C,  SOY_INSERT = 0x2D,
  SOY_DELETE = 0x2E,    SOY_HELP = 0x2F,      SOY_0 = 0x30,
  SOY_1 = 0x31,         SOY_2 = 0x32,         SOY_3 = 0x33,
  SOY_4 = 0x34,         SOY_5 = 0x35,         SOY_6 = 0x36,
  SOY_7 = 0x37,         SOY_8 = 0x38,         SOY_9 = 0x39,
  SOY_A = 0x41,         SOY_B = 0x42,         SOY_C = 0x43,
  SOY_D = 0x44,         SOY_E = 0x45,         SOY_F = 0x46,
  SOY_G = 0x47,         SOY_H = 0x48,         SOY_I = 0x49,
  SOY_J = 0x4A,         SOY_K = 0x4B,         SOY_L = 0x4C,
  SOY_M = 0x4D,         SOY_N = 0x4E,         SOY_O = 0x4F,
  SOY_P = 0x50,         SOY_Q = 0x51,         SOY_R = 0x52,
  SOY_S = 0x53,         SOY_T = 0x54,         SOY_U = 0x55,
  SOY_V = 0x56,         SOY_W = 0x57,         SOY_X = 0x58,
  SOY_Y = 0x59,         SOY_Z = 0x5A,         SOY_LSUPER = 0x5B,
  SOY_RSUPER = 0x5C,    SOY_APPS = 0x5D,      SOY_SLEEP = 0x5F,
  SOY_NUMPAD0 = 0x60,   SOY_NUMPAD1 = 0x61,   SOY_NUMPAD2 = 0x62,
  SOY_NUMPAD3 = 0x63,   SOY_NUMPAD4 = 0x64,   SOY_NUMPAD5 = 0x65,
  SOY_NUMPAD6 = 0x66,   SOY_NUMPAD7 = 0x67,   SOY_NUMPAD8 = 0x68,
  SOY_NUMPAD9 = 0x69,   SOY_MULTIPLY = 0x6A,  SOY_ADD = 0x6B,
  SOY_SEPARATOR = 0x6C, SOY_SUBTRACT = 0x6D,  SOY_DECIMAL = 0x6E,
  SOY_DIVIDE = 0x6F,    SOY_F1 = 0x70,        SOY_F2 = 0x71,
  SOY_F3 = 0x72,        SOY_F4 = 0x73,        SOY_F5 = 0x74,
  SOY_F6 = 0x75,        SOY_F7 = 0x76,        SOY_F8 = 0x77,
  SOY_F9 = 0x78,        SOY_F10 = 0x79,       SOY_F11 = 0x7A,
  SOY_F12 = 0x7B,       SOY_F13 = 0x7C,       SOY_F14 = 0x7D,
  SOY_F15 = 0x7E,       SOY_F16 = 0x7F,       SOY_F17 = 0x80,
  SOY_F18 = 0x81,       SOY_F19 = 0x82,       SOY_F20 = 0x83,
  SOY_F21 = 0x84,       SOY_F22 = 0x85,       SOY_F23 = 0x86,
  SOY_F24 = 0x87,       SOY_NUMLOCK = 0x90,   SOY_SCRLOCK = 0x91,
  SOY_LSHIFT = 0xA0,    SOY_RSHIFT = 0xA1,    SOY_LCONTROL = 0xA2,
  SOY_RCONTROL = 0xA3,  SOY_LALT = 0xA4,      SOY_RALT = 0xA5,
  SOY_VOLMUTE = 0xAD,   SOY_VOLDOWN = 0xAE,   SOY_VOLUP = 0xAF,
  SOY_MEDIANEXT = 0xB0, SOY_MEDIAPREV = 0xB1, SOY_MEDIASTOP = 0xB2,
  SOY_MEDIAPLAY = 0xB4, SOY_OEM_1 = 0xBA,     SOY_OEM_PLUS = 0xBB,
  SOY_OEM_COMMA = 0xBC, SOY_OEM_MINUS = 0xBD, SOY_OEM_PERIOD = 0xBE,
  SOY_OEM_2 = 0xBF,     SOY_OEM_3 = 0xC0,     SOY_OEM_4 = 0xDB,
  SOY_OEM_5 = 0xDC,     SOY_OEM_6 = 0xDD,     SOY_OEM_7 = 0xDE,
  SOY_OEM_8 = 0xDF,     SOY_OEM_102 = 0xE2,   SOY_ANY = 0xFF
} soyKeyCode;

typedef enum enum_soyMouseCode {
  SOY_MOUSE_NONE,
  SOY_MOUSE_LEFT,
  SOY_MOUSE_MID,
  SOY_MOUSE_RIGHT,
  SOY_MOUSE_X1
} soyMouseCode;

#define SOY_ASSERT(x) if(!(x)) {             \
printf(                                   \
    "ABORTING PROGRAM - FATAL ERROR at: " \
    "%s, line: %d, time: %s [%s]\n"       \
  , __FILE__, (int32)__LINE__, __TIME__, #x);    \
exit(-1);                                 \
}

/*=========================================================================*/
/* PLATFORM CALLBACKS                                                      */
/*=========================================================================*/

typedef int32 (*SOY_PFVOID) (void* p);
typedef int32 (*SOY_PFINT) (int32 i);
typedef int32 (*SOY_PFFLOAT) (real32 f);
typedef int32 (*SOY_PFCHAR) (void* p, uint8 key);
typedef int32 (*SOY_PFKEY) (void* p, int32 key, int32 code, int32 state);
typedef int32 (*SOY_PFMOUSEKEY) (void* p, int32 key, int32 state);
typedef int32 (*SOY_PFMOUSEMOVE) (void* p, int32 x, int32 y);
typedef int32 (*SOY_PFMOUSESCROLL) (void* p, int32 s);
typedef int32 (*SOY_PFWINFOCUS) (void* p, int32 s);
typedef int32 (*SOY_PFHITTEST) (void* p, int32* a, int32* b, int32* c);
typedef int32 (*SOY_PFRESIZE) (void* p, int32 x, int32 y, int32 w, int32 h);
typedef int32 (*SOY_PFMINMAX) (void* p, int32* w, int32* h);

SOY_PFVOID SOY_WIN_CREATE_CB = NULL;
SOY_PFVOID SOY_WIN_CLOSE_CB = NULL;
SOY_PFCHAR SOY_CHAR_CB = NULL;
SOY_PFKEY SOY_KEY_CB = NULL;
SOY_PFMOUSEKEY SOY_MOUSE_CB = NULL;
SOY_PFMOUSEMOVE SOY_MOUSE_MOVE_CB = NULL;
SOY_PFMOUSESCROLL SOY_MOUSE_SCROLL_CB = NULL;
SOY_PFWINFOCUS SOY_FOCUS_CB = NULL;
SOY_PFVOID SOY_REPAINT_CB = NULL;
SOY_PFVOID SOY_PAINT_CB = NULL;
SOY_PFVOID SOY_RENDER_CB = NULL;
SOY_PFFLOAT SOY_UPDATE_CB = NULL;
SOY_PFHITTEST SOY_HIT_TEST_CB = NULL;
SOY_PFRESIZE SOY_RESIZE_CB = NULL;
SOY_PFMINMAX SOY_MIN_MAX_CB = NULL;

/*=========================================================================*/
/* WIN32 LAYER                                                             */
/*=========================================================================*/

#ifdef SOY_WIN32

int64 SOY_clock(void) {
  int64 ret;
  QueryPerformanceCounter((LARGE_INTEGER*)&ret);
  return ret;
}

real64 SOY_clockDelta(int64 begin, int64 end) {
  LARGE_INTEGER qpFreq;
  QueryPerformanceFrequency(&qpFreq);
  return (real64)(end - begin) / (real64)qpFreq.QuadPart;
}

uint32 SOY_WIN_TIMER_ID = 1;
uint32 SOY_WIN_TIMER_SET = 0;

LRESULT CALLBACK SOY_windowEventCallback(
	HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
  RECT wndRect;
  int32 htMx = 0;
  int32 htMy = 0;
  int32 mmX = 0;
  int32 mmY = 0;
  int32 scaledBtnPad = 0;
  int32 scaledBorder = 4;
  int32 scaledTitle = 18;
  switch(msg){
    case(WM_LBUTTONDOWN): {
	  if(SOY_MOUSE_CB) { SOY_MOUSE_CB(hwnd, SOY_MOUSE_LEFT, 1); } 
	  return 0;
	}
    case(WM_MBUTTONDOWN): {
	  if(SOY_MOUSE_CB) { SOY_MOUSE_CB(hwnd, SOY_MOUSE_MID, 1); } 
	  return 0;
	}
    case(WM_RBUTTONDOWN): {
	  if(SOY_MOUSE_CB) { SOY_MOUSE_CB(hwnd, SOY_MOUSE_RIGHT, 1); } 
	  return 0;
	}
    case(WM_LBUTTONUP): {
	  if(SOY_MOUSE_CB) { SOY_MOUSE_CB(hwnd, SOY_MOUSE_LEFT, 0); } 
	  return 0;
	}
    case(WM_MBUTTONUP): {
	  if(SOY_MOUSE_CB) { SOY_MOUSE_CB(hwnd, SOY_MOUSE_MID, 0); } 
	  return 0;
	}
    case(WM_RBUTTONUP): {
	  if(SOY_MOUSE_CB) { SOY_MOUSE_CB(hwnd, SOY_MOUSE_RIGHT, 0); } 
	  return 0;
	}
    case(WM_CREATE): {
	  if(SOY_WIN_CREATE_CB) { SOY_WIN_CREATE_CB(hwnd); } 
	  return 0;
	}
    case(WM_KILLFOCUS): {
	  if(SOY_FOCUS_CB) { SOY_FOCUS_CB(hwnd, FALSE); }
      return 0;
    }
    case(WM_SETFOCUS): {
	  if(SOY_FOCUS_CB) { SOY_FOCUS_CB(hwnd, TRUE); }
      return 0;
    }
    case(WM_CHAR): {
	  if(SOY_CHAR_CB) { SOY_CHAR_CB(hwnd, (uint8)wParam); }
      return 0;
    }
    case(WM_KEYDOWN): {
	  if(SOY_KEY_CB) { 
		SOY_KEY_CB(hwnd, (int32)wParam, LOBYTE(HIWORD(lParam)), 1);
	  }
      return 0;
    }
    case(WM_KEYUP): {
      if(SOY_KEY_CB) { 
		SOY_KEY_CB(hwnd, (int32)wParam, LOBYTE(HIWORD(lParam)), 0);
	  }
      return 0;
    }
    case(WM_SYSKEYDOWN): {
      if(SOY_KEY_CB) {
		SOY_KEY_CB(hwnd, (int32)wParam, LOBYTE(HIWORD(lParam)), 1);
	  }
	  return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    case(WM_SYSKEYUP): {
      if(SOY_KEY_CB) {
		SOY_KEY_CB(hwnd, (int32)wParam, LOBYTE(HIWORD(lParam)), 0);
	  }
	  return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    case(WM_MOUSEMOVE): {
      if(SOY_MOUSE_MOVE_CB) {
		SOY_MOUSE_MOVE_CB(
			hwnd, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
	  }
	  return 0;
    }
    case(WM_MOUSEWHEEL): {
      if(SOY_MOUSE_SCROLL_CB) {
		SOY_MOUSE_SCROLL_CB(hwnd, GET_WHEEL_DELTA_WPARAM(wParam));
	  }
	  return 0;
    }
    case(WM_GETMINMAXINFO): {
      if(SOY_MIN_MAX_CB) {
        SOY_MIN_MAX_CB(hwnd, &mmX, &mmY);
        ((MINMAXINFO*)lParam)->ptMinTrackSize.x = mmX;
        ((MINMAXINFO*)lParam)->ptMinTrackSize.y = mmY;
	  }
	  return 0;
    }
    case(WM_ERASEBKGND): {
      if(SOY_PAINT_CB) { SOY_PAINT_CB(hwnd); }
	  return 0;
    }
    case(WM_SIZING): {
      GetWindowRect(hwnd, &wndRect);
      if(SOY_RESIZE_CB) {
		SOY_RESIZE_CB(hwnd,
			wndRect.left,
			wndRect.top,
			wndRect.right - wndRect.left,
			wndRect.bottom - wndRect.top);
	  }
	  return 0;
    }
    case(WM_MOVING): {
      GetWindowRect(hwnd, &wndRect);
      if(SOY_RESIZE_CB) {
		SOY_RESIZE_CB(hwnd,
          wndRect.left,
          wndRect.top,
          wndRect.right - wndRect.left,
          wndRect.bottom - wndRect.top);
	  }
	  return 0;
    }
    case(WM_ENTERSIZEMOVE): {
      if(!SOY_WIN_TIMER_SET) {
        SetTimer(hwnd, SOY_WIN_TIMER_ID, 1, NULL);
        SOY_WIN_TIMER_SET = 1;
      }
      return 0;
    }
    case(WM_EXITSIZEMOVE): {
      KillTimer(hwnd, SOY_WIN_TIMER_ID);
      SOY_WIN_TIMER_SET = 0;
      return 0;
    }
    case(WM_TIMER): {
      if(SOY_PAINT_CB) { SOY_PAINT_CB(hwnd); } 
	  return 0;
    }
    case(WM_MOUSEACTIVATE): {
      if(SOY_PAINT_CB && SOY_FOCUS_CB) {
        SOY_FOCUS_CB(hwnd, TRUE);
        SOY_PAINT_CB(hwnd);
	  }
		return 0;
    }
    case(WM_NCHITTEST): {
      GetWindowRect(hwnd, &wndRect);
      htMx = GET_X_LPARAM(lParam)-wndRect.left;
	  htMy = GET_Y_LPARAM(lParam)-wndRect.top;
	  if(SOY_HIT_TEST_CB) {
		if(!SOY_HIT_TEST_CB(
		  hwnd, &scaledTitle, &scaledBorder, &scaledBtnPad)) {
		  return HTCLIENT;
		}
	  }
      if(htMx >= 0 &&
          htMx <= wndRect.right - wndRect.left - scaledBtnPad &&
		  htMy > 0 && htMy <= scaledTitle) {
        return HTCAPTION;
	  } else if (htMx >= wndRect.right - wndRect.left - scaledBorder*2 &&
		  htMy >= wndRect.bottom - wndRect.top - scaledBorder*2) {
		return HTBOTTOMRIGHT;
	  } else if (htMx >= wndRect.right - wndRect.left - scaledBorder) {
		return HTRIGHT;
	  } else if (htMy >= wndRect.bottom - wndRect.top - scaledBorder) {
		return HTBOTTOM;
	  } else {
        return HTCLIENT;
	  }
    }
    case(WM_DESTROY): {
	  if(SOY_WIN_CLOSE_CB) {
		SOY_WIN_CLOSE_CB(hwnd);
	  }
	  PostQuitMessage(0);
      return 0;
    }
    case(WM_CLOSE): {
      if(MessageBoxA(hwnd, "Really quit?", ":(", MB_OKCANCEL) == IDOK) {
        DestroyWindow(hwnd);
        return 0;
      } else {
        return 0;
      }
    }
    default: {
      return DefWindowProc(hwnd, msg, wParam, lParam);
    }
  }
}

void* SOY_windowCreate(
    const int8* title, int32 x, int32 y, int32 width, int32 height) {
  WNDCLASSA winStyle;
  HINSTANCE hInstance = GetModuleHandle(NULL);
  void* ret;
  ATOM regRet;
  winStyle.lpszClassName = title;
  winStyle.lpfnWndProc = SOY_windowEventCallback;
  winStyle.style = CS_HREDRAW | CS_VREDRAW | CS_OWNDC;
  winStyle.cbClsExtra = 0;
  winStyle.cbWndExtra = 0;
  winStyle.hInstance = hInstance;
  winStyle.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
  winStyle.lpszMenuName = NULL;
  winStyle.hCursor = LoadCursor(NULL, IDC_ARROW);
  winStyle.hIcon = LoadIcon(NULL, IDI_APPLICATION);
  regRet = RegisterClassA(&winStyle);
  if(regRet == 0) {
	MessageBoxA(NULL, "Window Registration Failed!", "Error!",
        MB_ICONEXCLAMATION | MB_OK);
		return FALSE;
	}
	ret = CreateWindowA(
        title, title, WS_POPUP | WS_MINIMIZEBOX, x, y, width, height,
        NULL, NULL, hInstance, NULL);
    if(ret == NULL) {
        printf("Last error: %d\n", (int32)GetLastError());
        SOY_ASSERT("creating window\n");
		MessageBoxA(NULL, "Failed to create Window!", "Error!",
            MB_ICONEXCLAMATION | MB_OK);
		return FALSE;
    }
    ShowWindow(ret, SW_SHOW);
	SetForegroundWindow(ret);
	SetFocus(ret);
	UpdateWindow(ret);
    return ret;
}

int32 SOY_windowPollEvents(void* window) {
  MSG msg;
  while(PeekMessage(&msg, window, 0, 0, PM_REMOVE)) {
    if(msg.message == WM_QUIT) { return FALSE; }
    TranslateMessage(&msg);
    DispatchMessage(&msg);
  }
  return msg.message != WM_QUIT;
}

int32 SOY_windowBlit(
    void* window, uint8* buffer, int32 srcWidth, int32 srcHeight) {
  RECT wRect;
  BITMAPINFO bitmapInfo;
  bitmapInfo.bmiHeader.biSize = sizeof(bitmapInfo.bmiHeader);
  bitmapInfo.bmiHeader.biWidth = srcWidth;
  bitmapInfo.bmiHeader.biHeight = -srcHeight;
  bitmapInfo.bmiHeader.biPlanes = 1;
  bitmapInfo.bmiHeader.biBitCount = 32;
  bitmapInfo.bmiHeader.biCompression = BI_RGB;
  if(!GetWindowRect(window, &wRect)) {
    printf("GetWindowRect error: %ld\n", GetLastError());
  }
  if(StretchDIBits(
      GetDC(window),
      0, 0,
      wRect.right - wRect.left, wRect.bottom - wRect.top,
	  0, 0,
      srcWidth, srcHeight,
      buffer, &bitmapInfo, DIB_RGB_COLORS, SRCCOPY) != 0) {
    return TRUE;
  } else {
    printf("StretchDIBits error: %ld\n", GetLastError());
    return FALSE;
  }
}

static int32 SOY_ALLOCATION_COUNTER = 0;

void* SOY_memoryAllocate(size_t size) {
  SOY_ALLOCATION_COUNTER++;
  return VirtualAlloc(
      NULL,
      size,
      MEM_RESERVE | MEM_COMMIT,
      PAGE_READWRITE);
}

int32 SOY_memoryFree(void* memory) {
  SOY_ALLOCATION_COUNTER--;
  return VirtualFree(memory, 0, MEM_RELEASE);
}

void* SOY_memoryCopy(void* dest, void* src, size_t size) {
  return memcpy(dest, src, size);
}

void* SOY_memorySet(void* dest, int32 value, size_t size) {
  return memset(dest, value, size);
}

int32 SOY_sleep(int32 ms) {
  Sleep(ms);
  return TRUE;
}
#endif /* SOY_WIN32 */

/*=========================================================================*/
/* MEMORY                                                                  */
/*=========================================================================*/

typedef struct tag_soyMemorySector {
  uint8* base;
  size_t offset;
  size_t size;
  int8* label;
} soyMemorySector;

SOY_GLOBAL int32 g_soyAllocationCounter = 0;

int32 SOY_memorySectorCreate(int8* label, soyMemorySector* sector,
    size_t size) {
  sector->base = SOY_memoryAllocate(size);
  sector->label = label;
  if(sector->base != NULL) {
    sector->offset = 0;
    sector->size = size;
    g_soyAllocationCounter++;
  } else {
    printf("Error allocating memory sector\n");
    return -1;
  }
  printf("Allocated memory \"%s\" at [%p] [%dkb]"
           "Allocation counter: [%d]\n",
      label, sector->base, (uint32)(size / 1024), g_soyAllocationCounter);
  return TRUE;
}

int32 SOY_memorySectorFree(soyMemorySector* sector) {
  if(SOY_memoryFree(sector->base)) {
    sector->offset = 0;
    sector->size = 0;
    g_soyAllocationCounter--;
  } else {
    printf("Error freeing memory sector\n");
    return -1;
  }
  printf("Freed memory at [%p] Allocation counter: [%d]\n",
      sector->base, g_soyAllocationCounter);
  return TRUE;
}

int32 SOY_memorySectorPartition(int8* label,
    soyMemorySector* src, soyMemorySector* dest,
    size_t size) {
  SOY_ASSERT((size_t)src->offset + size < (size_t)src->size);
  dest->base = src->base + src->offset;
  dest->offset = 0;
  dest->size = size;
  src->offset += size;
  printf("Partitioned memory \"%s\" at [%p] [%dkb][%.1f%%]\n",
      label,
      dest->base,
      (uint32)(size / 1024),
      (((real32)src->offset)/((real32)src->size))*100.0f);
  return TRUE;
}

void* SOY_memorySectorReset(soyMemorySector* src) {
  src->offset = 0;
  return SOY_memorySet(src->base, 0, src->size);
}

/*=========================================================================*/
/* FILES                                                                   */
/*=========================================================================*/

void* SOY_fileOpen(int8* file, int8* args) {
  void* ret = fopen(file, args);
  if(!ret) { return NULL; }
  return ret;
}

int32 SOY_fileClose(void* file) {
  if(!file) { return FALSE; }
  return fclose((FILE*)file);
}

size_t SOY_fileSize(void* file) {
  size_t size = 0;
  if(!file) { return 0; }
  fseek((FILE*)file, 0, SEEK_END);
  size = ftell((FILE*)file);
  fseek((FILE*)file, 0, SEEK_SET);
  return size;
}

/*=========================================================================*/
/* CANVAS                                                                  */
/*=========================================================================*/

typedef struct tag_soyCanvas {
  int32 width;
  int32 height;
  uint32 colour;
  uint32* pixels;
} soyCanvas;

typedef uint32 soyPixel;

#define SOY_drawPixelFast(buffer, x, y, width, col) \
				buffer[(x) + (y)*(width)] = (col)
#define SOY_drawPixel(canvas, x, y) \
	canvas->pixels[x + y*canvas->width] = canvas->colour
#define SOY_drawSetColour(canvas, x) \
	canvas->colour = x
#define SOY_drawWidth(canvas) \
	canvas->width
#define SOY_drawHeight(canvas) \
	canvas->height
#define SOY_drawBuffer(canvas) \
    canvas->pixels

/*=========================================================================*/
/* TEXT                                                                    */
/*=========================================================================*/

#define SOY_MAX_FONT_MEMORY 32*32
#define SOY_MAX_DRAW_STRING 1024
#define SOY_MAX_FONT_GLYPHS 256

SOY_GLOBAL int8 g_soyDrawTextBuffer[SOY_MAX_DRAW_STRING];

typedef struct tag_soyFontFragment {
  uint8 x;
  uint8 y;
} soyFontFragment;

typedef struct tag_soyFontCharInfo {
  soyFontFragment fragments[SOY_MAX_FONT_MEMORY];
  int32 kerning;
  int32 fragCount;
} soyFontCharInfo;

typedef struct tag_soyFontData {
  int32 drawWidth;
  int32 drawHeight;
  int32 drawScale;
  int32 scaledDrawWidth;
  int32 scaledDrawHeight;
} soyFontData;

typedef struct tag_soyFont {
  int32 cellSize;
  soyFontData data;
  soyFontCharInfo glyphs[SOY_MAX_FONT_GLYPHS];
} soyFont;

int32 SOY_saveFont(soyFont* font, int8* filename) {
  int8 hdr[8] = { 'S', 'O', 'Y', 'F', 'O', 'N', 'T', '\n' };
  FILE* file = SOY_fileOpen(filename, "wb");
  if(file) {
    fwrite(hdr, sizeof(int8)*8, 1, file);
    fwrite(font, sizeof(font), 1, file);
    SOY_fileClose(file);
    return TRUE;
  } else {
    return FALSE;
  }
}

int32 SOY_loadFont(soyFont* font, int8* filename) {
  int8 hdr[8];
  FILE* file = SOY_fileOpen(filename, "rb");
  if(file) {
    fread(hdr, sizeof(int8)*8, 1, file);
    fread(font, sizeof(font), 1, file);
    SOY_fileClose(file);
    return TRUE;
  } else {
    return FALSE;
  }
}

int32 SOY_unpackFont(soyFont* font,
    const uint16* elements, int32 glyphs, int32 cellSize) {
  int32 i, j, bitIndex;
  int32 curTestBit;
  int32 maxX = 0;
  for(i = 0; i < SOY_MAX_FONT_GLYPHS; i++) {
    maxX = 0;
    for(j = 0; j < cellSize; j++) {
      for(bitIndex = 0; bitIndex < cellSize; bitIndex++) {
        if(i < glyphs) {
          curTestBit = elements[j + i*cellSize] & (1 << bitIndex);
          if(curTestBit) {
            font->glyphs[i].fragments[font->glyphs[i].fragCount].x =
              bitIndex;
            font->glyphs[i].fragments[font->glyphs[i].fragCount].y = j;
            font->glyphs[i].fragCount++;
            if(bitIndex > maxX) {
              maxX = bitIndex;
            }
          }
        } else {
          font->glyphs[i].fragments[font->glyphs[i].fragCount].x = bitIndex;
          font->glyphs[i].fragments[font->glyphs[i].fragCount].y = j;
          font->glyphs[i].fragCount++;
        }
      }
    }
    if(i == ' ') {
      font->glyphs[i].kerning = cellSize/2;
    } else {
      font->glyphs[i].kerning = maxX + 1;
    }
  }
  font->data.drawWidth = cellSize;
  font->data.drawHeight = cellSize;
  font->data.drawScale = 1;
  font->data.scaledDrawWidth = cellSize;
  font->data.scaledDrawHeight = cellSize;
  font->cellSize = cellSize;
  return TRUE;
}

int32 SOY_drawSetFontData(soyFont* font,
    int32 width, int32 height, int32 scale) {
  font->data.drawScale = scale;
  font->data.drawWidth = width;
  font->data.drawHeight = height;
  font->data.scaledDrawWidth = width*scale;
  font->data.scaledDrawHeight = height*scale;
  return TRUE;
}

soyFontData SOY_drawGetFontData(soyFont* font) {
  return font->data;
}

int32 SOY_drawChar(soyCanvas* hCanvas, soyFont* font,
    int32 x, int32 y, int8 chr) {
  int32 w = 0;
  int32 h = 0;
  int32 sx, sy, scx, scy;
  int32 cw, ch;
  int32 cx, cy;
  int32 fx;
  soyPixel col = hCanvas->colour;
  int32 dw = hCanvas->width;
  int32 dh = hCanvas->height;
  int8 curChar = chr;
  uint8 glyphIndex = (uint8)curChar;
  cw = font->data.drawWidth*font->data.drawScale;
  ch = font->data.drawHeight*font->data.drawScale;
  cx = w*cw;
  cy = h*ch;
  if(cx + cw >= 0 && cx <= dw && cy + ch >= 0 && cy <= dh) {
    glyphIndex = (uint8)curChar;
    for(fx = 0; fx < font->glyphs[(uint8)curChar].fragCount; fx++) {
      for(sy = 0; sy < font->data.drawScale; sy++) {
        for(sx = 0; sx < font->data.drawScale; sx++) {
          scx = x+sx+font->glyphs[glyphIndex].fragments[fx].x*
            font->data.drawScale+cx;
          scy = y+sy+font->glyphs[glyphIndex].fragments[fx].y*
            font->data.drawScale+cy;
          if(scx >= 0 && scx < hCanvas->width &&
              scy >= 0 && scy < hCanvas->height) {
            SOY_drawPixel(hCanvas, scx, scy);
          }
        }
      }
    }
  }
  SOY_drawSetColour(hCanvas, col);
  return TRUE;
}

int32 SOY_drawTextMono(soyCanvas* hCanvas, soyFont* font,
    int32 x, int32 y, int8* text) {
  int32 i = 0;
  int32 h = 0;
  int32 sx, sy, scx, scy;
  int32 cw, ch;
  int32 cx, cy;
  int32 fx;
  soyPixel col = hCanvas->colour;
  int32 dw = hCanvas->width;
  int32 dh = hCanvas->height;
  int8 curChar = text[0];
  uint8 glyphIndex = (uint8)curChar;
  cx = 0;
  cy = 0;
  while((curChar = text[i++])) {
    while(curChar == '\n' && curChar) {
      h++;
      cx = 0;
      curChar = text[i++];
    }
    ch = font->data.drawHeight*font->data.drawScale;
    cw = font->data.drawWidth*font->data.drawScale;
    cy = h*ch;
    if(cx + cw >= 0 && cx <= dw && cy + ch >= 0 && cy <= dh) {
      glyphIndex = (uint8)curChar;
      for(fx = 0; fx < font->glyphs[(uint8)curChar].fragCount; fx++) {
        for(sy = 0; sy < font->data.drawScale; sy++) {
          for(sx = 0; sx < font->data.drawScale; sx++) {
            scx = x+sx+font->glyphs[glyphIndex].fragments[fx].x*
              font->data.drawScale+cx;
            scy = y+sy+font->glyphs[glyphIndex].fragments[fx].y*
              font->data.drawScale+cy;
            if(scx >= 0 && scx < hCanvas->width &&
              scy >= 0 && scy < hCanvas->height) {
              SOY_drawPixel(hCanvas, scx, scy);
            }
          }
        }
      }
    }
    cx += cw;
  }
  SOY_drawSetColour(hCanvas, col);
  return TRUE;
}

int32 SOY_drawText(soyCanvas* hCanvas, soyFont* font,
    int32 x, int32 y, int8* text) {
  int32 i = 0;
  int32 h = 0;
  int32 sx, sy, scx, scy;
  int32 cw, ch;
  int32 cx, cy;
  int32 fx;
  int32 maxX = 0;
  soyPixel col = hCanvas->colour;
  int32 dw = hCanvas->width;
  int32 dh = hCanvas->height;
  int8 curChar = text[0];
  uint8 glyphIndex = (uint8)curChar;
  cx = 0;
  cy = 0;
  while((curChar = text[i++])) {
    while(curChar == '\n' && curChar) {
      h++;
      cx = 0;
      curChar = text[i++];
    }
    cw = font->glyphs[(uint8)curChar].kerning*font->data.drawScale;
    ch = font->data.drawHeight*font->data.drawScale;
    cy = h*ch;
    if(cx + cw >= 0 && cx <= dw && cy + ch >= 0 && cy <= dh) {
      glyphIndex = (uint8)curChar;
      for(fx = 0; fx < font->glyphs[(uint8)curChar].fragCount; fx++) {
        for(sy = 0; sy < font->data.drawScale; sy++) {
          for(sx = 0; sx < font->data.drawScale; sx++) {
            scx = x+sx+font->glyphs[glyphIndex].fragments[fx].x*
              font->data.drawScale+cx;
            scy = y+sy+font->glyphs[glyphIndex].fragments[fx].y*
              font->data.drawScale+cy;
            if(scx >= 0 && scx < hCanvas->width &&
              scy >= 0 && scy < hCanvas->height) {
                SOY_drawPixel(hCanvas, scx, scy);
            }
          }
        }
      }
    }
    if(cx > maxX) { maxX = cx; }
    cx += cw;
  }
  SOY_drawSetColour(hCanvas, col);
  return maxX;
}

int32 SOY_drawTextWidth(soyFont* font, int8* text) {
  int32 i = 0;
  int32 h = 0;
  int32 cw;
  int32 cx;
  int32 maxX = 0;
  int8 curChar = text[0];
  cx = 0;
  while((curChar = text[i++])) {
    while(curChar == '\n' && curChar) {
      h++;
      cx = 0;
      curChar = text[i++];
    }
    cw = font->glyphs[(uint8)curChar].kerning*font->data.drawScale;
    cx += cw;
    if(cx > maxX) { maxX = cx; }
  }
  return maxX;
}

uint32 SOY_drawTextFlush() {
  SOY_memorySet(g_soyDrawTextBuffer, 0, sizeof(g_soyDrawTextBuffer));
  return TRUE;
}

int32 SOY_drawTextFormat(soyCanvas* hCanvas, soyFont* font,
    int32 x, int32 y, int8* format, ...) {
  va_list args;
  SOY_drawTextFlush();
  va_start(args, format);
  vsnprintf(g_soyDrawTextBuffer, SOY_MAX_DRAW_STRING, format, args);
  va_end(args);
  SOY_drawText(hCanvas, font, x, y, g_soyDrawTextBuffer);
  return TRUE;
}

int32 SOY_drawTextMonoFormat(soyCanvas* hCanvas, soyFont* font,
    int32 x, int32 y, int8* format, ...) {
  va_list args;
  SOY_drawTextFlush();
  va_start(args, format);
  vsnprintf(g_soyDrawTextBuffer, SOY_MAX_DRAW_STRING, format, args);
  va_end(args);
  SOY_drawTextMono(hCanvas, font, x, y, g_soyDrawTextBuffer);
  return TRUE;
}

/*=========================================================================*/
/* ENGINE                                                                  */
/*=========================================================================*/

typedef struct tag_soyApp soyApp;

typedef int32 (*SOY_PFUSERUPDATE) (soyApp* app, real64 delta);

struct tag_soyApp {
  soyCanvas* framebuffer;
  soyFont* font;
  SOY_PFUSERUPDATE userUpdate;
  SOY_PFUSERUPDATE userDraw;
  int64 timer;  
  real64 delta;
  int8* title;
  int32 kill;
  int32 resolution;
  int32 windowWidth;
  int32 windowHeight;
};

static soyApp SOY_APP;
static soyCanvas SOY_FRAMEBUFFER;
static soyFont SOY_FONT;

int32 SOY_userUpdate(soyApp* app, real64 delta);
int32 SOY_userRender(soyApp* app, real64 delta);

/* PLATFORM CALLBACKS ******************************************************/

int32 SOY_platformPaint(void* p) {
  SOY_APP.timer = SOY_clock();
  SOY_APP.userUpdate(&SOY_APP, SOY_APP.delta);
  SOY_APP.userDraw(&SOY_APP, SOY_APP.delta);
  SOY_APP.delta = SOY_clockDelta(SOY_APP.timer, SOY_clock());
  SOY_windowBlit(
      p, (uint8*)SOY_APP.framebuffer->pixels,
      SOY_APP.framebuffer->width,
      SOY_APP.framebuffer->height);
  return TRUE;
}

int32 SOY_platformResize(void* p, int32 x, int32 y, int32 w, int32 h) {
  SOY_APP.windowWidth = w;
  SOY_APP.windowHeight = h;
  SOY_APP.framebuffer->width = w/SOY_APP.resolution;
  SOY_APP.framebuffer->height = h/SOY_APP.resolution;
  return TRUE;
}

int32 SOY_platformClose(void* p) {
  SOY_APP.kill = TRUE;
  return TRUE;
}

int32 SOY_platformRegisterGlobalCallbacks() {
  SOY_PAINT_CB = SOY_platformPaint;
  SOY_RESIZE_CB = SOY_platformResize;
  SOY_WIN_CLOSE_CB = SOY_platformClose;
  return TRUE;
}


/* PUBLIC METHODS **********************************************************/

#define MAX_WIDTH 1920*2
#define MAX_HEIGHT 1080*2

int32 SOY_create(soyApp* app, int8* title, int32 width, int32 height) {
  int32 resolution = 2;
  void* window = SOY_windowCreate("SOY", 100, 100, width, height);
  SOY_platformRegisterGlobalCallbacks();
  SOY_APP.font = &SOY_FONT;
  SOY_APP.framebuffer = &SOY_FRAMEBUFFER;
  SOY_APP.kill = FALSE;
  SOY_APP.title = title;
  SOY_APP.windowWidth = width;
  SOY_APP.windowHeight = height;
  SOY_APP.resolution = resolution;
  SOY_APP.framebuffer->colour = 0xFFFFFFFF;
  SOY_APP.framebuffer->width = width/resolution;
  SOY_APP.framebuffer->height = height/resolution;
  SOY_APP.framebuffer->pixels = 
    SOY_memoryAllocate(MAX_WIDTH*MAX_HEIGHT*sizeof(uint32));
  SOY_APP.userUpdate = SOY_userUpdate;
  SOY_APP.userDraw = SOY_userRender;
  
  SOY_unpackFont(&SOY_FONT, g_packedFont0, 128, 14);
  SOY_drawSetFontData(&SOY_FONT, 7, 14, 1);
  SOY_drawTextFlush();

  while(!SOY_APP.kill) {
		SOY_platformPaint(window);
    SOY_windowPollEvents(window);
    SOY_sleep(8);
  }
  return app == NULL;
}

int32 SOY_width(soyApp* app) {
  return app->framebuffer->width;
}

int32 SOY_height(soyApp* app) {
  return app->framebuffer->width;
}

#endif /* SOY_LIB_MINI_H */
